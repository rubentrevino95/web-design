<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/cars.css">
    <title>Cars game</title>
</head>
<body>
    <div id="score">Press UP</div>

    <div id="controls">
        <div id="buttons">
            <button id="accelerate">
            <svg width="30" height="30" viewBox="0 0 10 10">
                <g transform="rotate(0, 5,5)">
                <path d="M5,4 L7,6 L3,6 L5,4" />
                </g>
            </svg>
            </button>
            <button id="decelerate">
            <svg width="30" height="30" viewBox="0 0 10 10">
                <g transform="rotate(180, 5,5)">
                <path d="M5,4 L7,6 L3,6 L5,4" />
                </g>
            </svg>
            </button>
        </div>
        <div id="instructions">
            Press UP to start. Avoid collision with other vehicles by accelerating
            or decelerating with the UP and DOWN keys.
        </div>
    </div>

    <div id="results">
        <div class="content">
            <h1>You hit another vehicle</h1>
            <p>To reset the game press R</p>
        </div>
    </div>
    <script>
        window.focus(); // Capture keys right away (by default focus is on editor)

        // Pick a random value from an array
        function pickRandom(array) {
        return array[Math.floor(Math.random() * array.length)];
        }

        // The Pythagorean theorem says that the distance between two points is
        // the square root of the sum of the horizontal and vertical distance's square
        function getDistance(coordinate1, coordinate2) {
        const horizontalDistance = coordinate2.x - coordinate1.x;
        const verticalDistance = coordinate2.y - coordinate1.y;
        return Math.sqrt(horizontalDistance ** 2 + verticalDistance ** 2);
        }

        const vehicleColors = [
        0xa52523,
        0xef2d56,
        0x0ad3ff,
        0xff9f1c /*0xa52523, 0xbdb638, 0x78b14b*/
        ];

        const lawnGreen = "#67C240";
        const trackColor = "#546E90";
        const edgeColor = "#725F48";
        const treeCrownColor = 0x498c2c;
        const treeTrunkColor = 0x4b3f2f;

        const wheelGeometry = new THREE.BoxBufferGeometry(12, 33, 12);
        const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
        const treeTrunkGeometry = new THREE.BoxBufferGeometry(15, 15, 30);
        const treeTrunkMaterial = new THREE.MeshLambertMaterial({
        color: treeTrunkColor
        });
        const treeCrownMaterial = new THREE.MeshLambertMaterial({
        color: treeCrownColor
        });
        const config = {
            showHitZones: false,
            shadows: true, // Use shadow
            trees: true, // Add trees to the map
            curbs: true, // Show texture on the extruded geometry
            grid: false // Show grid helper
        };

        let score;
        const speed = 0.0017;

        const playerAngleInitial = Math.PI;
        let playerAngleMoved;
        let accelerate = false; // Is the player accelerating
        let decelerate = false; // Is the player decelerating

        let otherVehicles = [];
        let ready;
        let lastTimestamp;

        const trackRadius = 225;
        const trackWidth = 45;
        const innerTrackRadius = trackRadius - trackWidth;
        const outerTrackRadius = trackRadius + trackWidth;

        const arcAngle1 = (1 / 3) * Math.PI; // 60 degrees

        const deltaY = Math.sin(arcAngle1) * innerTrackRadius;
        const arcAngle2 = Math.asin(deltaY / outerTrackRadius);

        const arcCenterX =
        (Math.cos(arcAngle1) * innerTrackRadius +
            Math.cos(arcAngle2) * outerTrackRadius) /
        2;

        const arcAngle3 = Math.acos(arcCenterX / innerTrackRadius);

        const arcAngle4 = Math.acos(arcCenterX / outerTrackRadius);

        const scoreElement = document.getElementById("score");
        const buttonsElement = document.getElementById("buttons");
        const instructionsElement = document.getElementById("instructions");
        const resultsElement = document.getElementById("results");
        const accelerateButton = document.getElementById("accelerate");
        const decelerateButton = document.getElementById("decelerate");

        setTimeout(() => {
        if (ready) instructionsElement.style.opacity = 1;
        buttonsElement.style.opacity = 1;
        }, 4000);

        // Initialize ThreeJs
        // Set up camera
        const aspectRatio = window.innerWidth / window.innerHeight;
        const cameraWidth = 960;
        const cameraHeight = cameraWidth / aspectRatio;

        const camera = new THREE.OrthographicCamera(
        cameraWidth / -2, // left
        cameraWidth / 2, // right
        cameraHeight / 2, // top
        cameraHeight / -2, // bottom
        50, // near plane
        700 // far plane
        );

        camera.position.set(0, -210, 300);
        camera.lookAt(0, 0, 0);

        const scene = new THREE.Scene();

        const playerCar = Car();
        scene.add(playerCar);

        renderMap(cameraWidth, cameraHeight * 2); // The map height is higher because we look at the map from an angle

        // Set up lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(100, -300, 300);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.camera.left = -400;
        dirLight.shadow.camera.right = 350;
        dirLight.shadow.camera.top = 400;
        dirLight.shadow.camera.bottom = -300;
        dirLight.shadow.camera.near = 100;
        dirLight.shadow.camera.far = 800;
        scene.add(dirLight);

        // const cameraHelper = new THREE.CameraHelper(dirLight.shadow.camera);
        // scene.add(cameraHelper);

        if (config.grid) {
        const gridHelper = new THREE.GridHelper(80, 8);
        gridHelper.rotation.x = Math.PI / 2;
        scene.add(gridHelper);
        }

        // Set up renderer
        const renderer = new THREE.WebGLRenderer({
        antialias: true,
        powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (config.shadows) renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        reset();

        function reset() {
        // Reset position and score
        playerAngleMoved = 0;
        score = 0;
        scoreElement.innerText = "Press UP";

        // Remove other vehicles
        otherVehicles.forEach((vehicle) => {
            // Remove the vehicle from the scene
            scene.remove(vehicle.mesh);

            // If it has hit-zone helpers then remove them as well
            if (vehicle.mesh.userData.hitZone1)
            scene.remove(vehicle.mesh.userData.hitZone1);
            if (vehicle.mesh.userData.hitZone2)
            scene.remove(vehicle.mesh.userData.hitZone2);
            if (vehicle.mesh.userData.hitZone3)
            scene.remove(vehicle.mesh.userData.hitZone3);
        });
        otherVehicles = [];

        resultsElement.style.display = "none";

        lastTimestamp = undefined;

        // Place the player's car to the starting position
        movePlayerCar(0);

        // Render the scene
        renderer.render(scene, camera);

        ready = true;
        }

        function startGame() {
        if (ready) {
            ready = false;
            scoreElement.innerText = 0;
            buttonsElement.style.opacity = 1;
            instructionsElement.style.opacity = 0;
            youtubeLogo.style.opacity = 1;
            renderer.setAnimationLoop(animation);
        }
    }

    </script>
</body>
</html>